# -*- coding: utf-8 -*-
"""
Complete this code for continuous optimization  problem

Please remove author name if generated by machine automatically
Keep you code anonymous

"""

# Use standard python package only.
import random 
import math
import numpy as np
import matplotlib as plt
import random as rng
from numpy import random



# MINIMUM GLOBAL VARIABLES TO BE USED
POPULATION_SIZE = 50 # Change POPULATION_SIZE to obtain better fitness.

GENERATIONS = 1000# Change GENERATIONS to obtain better fitness.
SOLUTION_FOUND = False

CORSSOVER_RATE = 0.8 # Change CORSSOVER_RATE  to obtain better fitness.
MUTATION_RATE = 0.2# Change MUTATION_RATE to obtain better fitness.

GENE_LENGTH = 4

UPPER_BOUND = 4
LOWER_BOUND = -4

# MINIMUM FUNCTIONS TO BE USED IN YOU COURSEWORK
def generate_population():

    population = []
    population = random.uniform(LOWER_BOUND, UPPER_BOUND, size=(POPULATION_SIZE, GENE_LENGTH))
    #np.round(
    population = population.tolist()
  
    return population


def compute_fitness(individual):
    # fitness function used - sum squares function
    # using for a minimisation problem where the goal is to get 0
    n = len(individual)
    fitness = 0
    for j in range(0,n):
     
       fitness = fitness + (j+1)*int(individual[j])**2
    
    return fitness

def compute_fitnessDixon(individual):
    # fitness function used - sum squares function
    # using for a minimisation problem where the goal is to get 0
    n = len(individual)
    fitness = 0
    for j in range(1,n):
       fitness =fitness+(j+1)*(2*individual[j]**2-individual[j-1])**2
    fitnes = fitness+(individual[0]-1)**2;
    return fitness

def compute_fitnessLevy(individual):
    n = len(individual)
    fitness = 0
    z= []
    for j in range(0,n):
       z.append(1+(individual[j]-1)/4)
    s = np.sin(np.pi*z[0])**2;
    for i in range(0,n-1):
        s = s+(z[i]-1)**2*(1+10*(np.sin(np.pi*z[i]+1))**2)
    fitness =  s+(z[n-1]-1)**2*(1+(np.sin(2*np.pi*z[n-1]))**2)
   # print ("ans " + str(fitness))
    return fitness


def compute_fitnessZakharov(individual):
    n = len(individual)
    fitness = 0
    sum1 = 0
    sum2 = 0
    for j in range(0,n):
        sum1 = sum1+individual[j] ** 2;
        sum2 = sum2+((j+1)*individual[j])/2;
    fitness = sum1 +sum2**2 + sum2**4;
    return fitness

def compute_fitnessPerm(individual):
    n = len(individual)
    b = 0.5
    fitness = 0
    for i in range(0,n):
        s_in = 0
        for j in range(0,n):
            s_in = s_in + (((j+1)**(i +1)) + b) * ((individual[j]/(j+1))**i)
        fitness = fitness + s_in ** 2
    return fitness

def perm( x, b=.5 ):
    x = np.asarray_chkfinite(x)
    n = len(x)
    j = np.arange( 1., n+1 )
    xbyj = np.fabs(x) / j
    return sum([ sum( (j**k + b) * ((x / j) ** k - 1) ) **2
             for k in j ])

def selection(population):
    # need to decide on an operation more appropriete
    individual = [] 
    for i in (population):
       #individual.append(compute_fitness(i));
       #individual.append(compute_fitnessDixon(i));
       #individual.append(compute_fitnessLevy(i));
       #individual.append(compute_fitnessZakharov(i));
       #individual.append(compute_fitnessPerm(i));
       individual.append(perm(i));
    return individual
    

def crossover(first_parent, second_parent):
    #implimenting single point crossover recombination
    individual = []
    crossProb = rng.random() 
    if crossProb < CORSSOVER_RATE:
        pos = rng.randint(0,GENE_LENGTH-1)
        individual.append(first_parent[:pos] +  second_parent[pos:])
        individual.append(first_parent[pos:] +  second_parent[:pos])
        return individual
    else:
        individual.append(first_parent)
        individual.append(second_parent)
        return individual
        


def mutation(individual):
    #need to glabalise the mutation bounds 
    # single bit point mutation
    if rng.random() < MUTATION_RATE:
        posRng = rng.randint(0,np.size(individual) -1)
        newMut = LOWER_BOUND + (UPPER_BOUND-LOWER_BOUND)*random.random()
        #newMut = rng.random_sample(LOWER_BOUND, UPPER_BOUND)
        while newMut == individual[posRng]:
            newMut = rng.randint(LOWER_BOUND, UPPER_BOUND)
        individual[posRng] = newMut
    return individual


def findParents(fitness):
    #selection with to find values with lowest zeros 
    #creates a list with the indexs of the genes from greatest fitness to lowest fitness
     parentsIndex = []
     orderedVal = []     
     orderedVal = fitness.copy()
     orderedVal.sort()
   #  print( "best fitness" + str(orderedVal[0]) + "\n")
     for j in range (0, np.size(orderedVal)):
        for i in range(0,np.size(fitness)):
             if  fitness[i] == orderedVal[j]:
                 if i not in parentsIndex:
                    parentsIndex.append(i);
                    break;
     
     return parentsIndex


def next_generation(previous_population):
    fitness = selection(previous_population)
    parents = findParents(fitness)
    
    next_generation = []
    parentPos = 0;
    while parentPos < len(previous_population):
        children = crossover(previous_population[parents[parentPos]],previous_population[parents[parentPos + 1]])
        if children != None:
            next_generation.append(children[0])
            next_generation.append(children[1])
        parentPos = parentPos + 2
    
    mutatedPopulation = []
    for i in next_generation.copy():
         mutatedPopulation.append(mutation(i))
    #print (" next gen " + str(mutatedPopulation) + "\n")
    return mutatedPopulation
    



# USE THIS MAIN FUNCTION TO COMPLETE YOUR CODE - MAKE SURE IT WILL RUN FROM COMOND LINE   
def main(): 
    global POPULATION_SIZE 
    global GENERATIONS
    global SOLUTION_FOUND
    global GENE_LENGTH
    global UPPER_BOUND
    global LOWER_BOUND
    currentGeneration = 0
   # currentBestFitness = 0

    print ("mine " + str(compute_fitnessPerm([-0.21624661652620425, 3.71776235123155, -3.286788105194205, 3.309679123599082])))
    print ("his " + str(perm([-0.21624661652620425, 3.71776235123155, -3.286788105194205, 3.309679123599082])))

    population = generate_population()
    fitness = selection(population)
    parents = findParents(fitness)
    avg = sum(fitness)/len(fitness)

    #currentBestFitness = fitness[parents[0]]
   # print ("first gen " + str(population) + "\n")
   # print ("Generation {} | Generation averge fitness {} \n".format(currentGeneration,avg,))
    print("fitness " + str(fitness) + "\n")
   
    while (SOLUTION_FOUND == False):  # TODO: write your termination condition here or within the loop  
        currentGeneration = currentGeneration + 1
        population  = next_generation(population)
        fitness = selection(population)
        avg = sum(fitness)/len(fitness)       
    #    print ("Generation {} | Generation averge fitness {} \n".format(currentGeneration,avg))
        
       # print("fitness " + str(fitness) + "\n")
        if 0 in fitness:
            SOLUTION_FOUND = True
            print ("The solution is " + str(population[fitness.index(0)]) + " in " + str(currentGeneration) + " generations")
        elif currentGeneration < GENERATIONS and len(population) > 1:
            currentGeneration = currentGeneration + 1
        else:
            print ("The solution was not found ")
            bestAttempt = []
            bestAttempt = fitness.copy()
            bestAttempt.sort()
            print("fitness " + str(bestAttempt) + "\n")
            print ("The closest solution is " + str(population[parents[0]]) + " in " + str(currentGeneration) + " generations")
            break;
        
 

if __name__ == '__main__': 
    main() 
    