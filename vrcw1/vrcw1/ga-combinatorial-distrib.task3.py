# -*- coding: utf-8 -*-
"""
Complete this code for combinatorial optimization  problem

Please remove author name if generated by machine automatically
Keep you code anonymous

"""

# Use standard python package only.
import random 
import math
import numpy as np
import matplotlib as plt
from numpy import random 

# MINIMUM GLOBAL VARIABLES TO BE USED
POPULATION_SIZE = 100 # Change POPULATION_SIZE to obtain better fitness.

GENERATIONS = 50 # Change GENERATIONS to obtain better fitness.
SOLUTION_FOUND = False

CORSSOVER_RATE = 0.8 # Change CORSSOVER_RATE  to obtain better fitness.
MUTATION_RATE = 0.5 # Change MUTATION_RATE to obtain better fitness.
GENE_LENGTH = 10
VARSET = [0,1]

# MINIMUM FUNCTIONS TO BE USED IN YOU COURSEWORK
def generate_population():
 
    population = []
    population = random.choice(VARSET,size=(POPULATION_SIZE, GENE_LENGTH))
   
    population = population.tolist() 
    
    return population

def generate_populationBin(binThresh, weights):
 
    genSet = VARSET.tolist()
    population = []
    popSize = POPULATION_SIZE -1
    print ("size {}".format(popSize))
    while sum(genSet) != 0:
        bWeight = 0
        itemsToAdd = []
       # print("genSet sum {}".format(sum(genSet)))
        while sum(genSet) != 0:
            nextItem = random.choice(genSet)
            print("damage done {} current node {}".format((len(genSet) - len(itemsToAdd)), popSize))
            if ((len(genSet) - len(itemsToAdd)) < popSize):
                break;
            elif (bWeight + weights[nextItem])> binThresh:
                break
            else:
                itemsToAdd.append(nextItem)
                genSet.remove(nextItem)
                bWeight = bWeight + weights[nextItem]
                
        population.append(itemsToAdd)
        popSize = popSize - 1
    #population = population.tolist
    print ("lets hope this works {}".format(population))
    return population

def compute_fitness(individual):
    
    fitness = sum(individual)
    print ("current fitness {}\n".format(fitness) )
    return fitness

def compute_fitnessKnap(individual, weights, values, threshold):
    
    fitness = []
    sumW = 0
    sumV = 0
    for i in range(0, len(individual)):
        sumW = sumW + individual[i] * weights[i]
        sumV = sumV + individual[i] * values[i]
    if (sumW > threshold):
        fitness = 0 
    else:
        fitness = sumV
   # print ("sum W {} fitness {} \n".format(sumW , fitness ))
    return fitness

def compute_fitnessQueue(individual):
    fitness = 0
    #index = X value of indexed position = Y
    # deals with the rows
    for i in range(0,len(individual)):
        fitness = fitness + calcDiag(i, individual[i], individual)
        for j in range(0,len(individual)):
           if i != j:
                if individual[j] == individual[i]:
                    fitness = fitness + 1
   # print ("fitness {}\n".format(fitness))
    return fitness

def calcDiag(indPos, indVal, individual):
    
    fitness = 0
    dir = [-1,1]
    for i in dir:
       for j in dir:
        x = indPos + i
        y = indVal + j
        while (x <= 3 and y <= 3 and y >=0  and x >= 0):
            if individual[x] == y:
                fitness = fitness + 1
            x = x + i
            y = y + j

    return fitness
def selectionQueue(population):

    individual = [] 
    for i in population:
        individual.append(compute_fitnessQueue(i))
    return individual

def selectionKnap(population,weights, values, threshold):

    individual = [] 
    for i in population:
        individual.append(compute_fitnessKnap(i, weights, values, threshold))
    
    return individual
    

def selection(population):

    individual = [] 
    for i in population:
        individual.append(compute_fitness(i))
    
    return individual

def crossover(first_parent, second_parent):
   #implimenting single point crossover recombination
    individual = []
    crossProb = random.rand()
    if crossProb < CORSSOVER_RATE:
        pos = random.randint(0,GENE_LENGTH-1)
        individual.append(first_parent[:pos] +  second_parent[pos:])
        individual.append(first_parent[pos:] +  second_parent[:pos])
        return individual
    else:
        individual.append(first_parent)
        individual.append(second_parent)
        return individual
    
    return individual

def mutation(individual):
    
     #need to glabalise the mutation bounds 
    # single bit point mutation
    if random.rand() < MUTATION_RATE:
        posRng = random.randint(0,np.size(individual) -1)
        newMut = random.choice(VARSET)
        while newMut == individual[posRng]:
            newMut = random.choice(VARSET)
        individual[posRng] = newMut
    
    return individual

#TODO : You can increase number of function to be used to improve your GA code 

def findParents(fitness, order):
    #selection with to find values with lowest zeros 
    #creates a list with the indexs of the genes from greatest fitness to lowest fitness
     parentsIndex = []
     orderedVal = []     
     orderedVal = fitness.copy()
     orderedVal.sort(reverse = order)
   #  print( "best fitness" + str(orderedVal[0]) + "\n")
     for j in range (0, np.size(orderedVal)):
        for i in range(0,np.size(fitness)):
             if  fitness[i] == orderedVal[j]:
                 if i not in parentsIndex:
                    parentsIndex.append(i);
                    break;
     test = fitness.copy()
     test.sort(reverse = True)
     #print('current fittness {} \n'.format(test))
    # print('parent index {} \n '.format(parentsIndex))
     return parentsIndex
    

def knap():
    currentBest = [];
    currentBestFitness = 0 
    curGen = 0;
    item_number = np.arange(1,11)
    weight = np.random.randint(1, 15, size = 10)
    value = np.random.randint(10, 750, size = 10)
    knapsack_threshold = 35    #Maximum weight that the bag of thief can hold 
    print('The list is as follows:')
    print('Item No.   Weight   Value')
    for i in range(item_number.shape[0]):
        print('{0}          {1}         {2}\n'.format(item_number[i], weight[i], value[i]))

    population = generate_population()
    
    print("population  " + str(population))
   # print('complete code for a combinitorial optimization problem:')
    while (True):  
        curGen = curGen + 1
        fitness = selectionKnap(population, weight, value, knapsack_threshold)
        parents = findParents(fitness, True)

        if curGen > GENERATIONS:
            print ("best fitness  {0} \n".format(currentBestFitness))
            
            print ("best values  {0} \n".format(currentBest))

            for i in range (0,len(currentBest)):
                print ("{}".format(currentBest[i] * (i +1)))
            break;

        if fitness[parents[0]] > currentBestFitness:
            currentBestFitness = fitness[parents[0]]
            currentBest = population[parents[0]]
        next_generation = []
        parentPos = 0;
        while parentPos < len(population):
            children = crossover(population[parents[parentPos]],population[parents[parentPos + 1]])
            if children != None:
                next_generation.append(children[0])
                next_generation.append(children[1])
            parentPos = parentPos + 2
   
        mutatedPopulation = []
        for i in next_generation.copy():
            mutatedPopulation.append(mutation(i))
      
        population = mutatedPopulation
        print("Generation {0} | population  \n".format(curGen) + str(population))


def minSum():
    curGen = 0
    global GENE_LENGTH 
    global VARSET
    GENE_LENGTH = 4
    VARSET = np.arange(0,GENE_LENGTH )

    population = generate_population()
    print("population  " + str(population))
   
    while (True):  
        curGen = curGen + 1
        fitness = selection(population)
        parents = findParents(fitness, False)

        if 0 in fitness:
            print ("solution found  {} \n".format(population[fitness.index(0)]))
            break;
        if curGen > GENERATIONS:
            print ("Soloution not found \n")
            
            print ("last Generation {}\n last fitness {}".format(population,fitness))
            break;

        next_generation = []
        parentPos = 0;
        while parentPos < len(population):
            children = crossover(population[parents[parentPos]],population[parents[parentPos + 1]])
            if children != None:
                next_generation.append(children[0])
                next_generation.append(children[1])
            parentPos = parentPos + 2
   
        mutatedPopulation = []
        for i in next_generation.copy():
            mutatedPopulation.append(mutation(i))
      
        population = mutatedPopulation
        print("Generation {0} | population  \n".format(curGen) + str(population))


def nQueue():
    curGen = 0
    global GENE_LENGTH 
    global VARSET
    GENE_LENGTH = 4
    VARSET = np.arange(0,GENE_LENGTH )
    population = []
    population = generate_population()

    print("population  {} \n".format(population))
   
    while (True):  
        fitness = selectionQueue(population)
        parents = findParents(fitness, False)

        if 0 in fitness:
            print ("solution found  {} \n".format(population[fitness.index(0)]))
            break;
        if curGen > GENERATIONS:
            print ("Soloution not found \n")
            
            print ("last Generation {}\n last fitness {}".format(population,fitness))
            break;

        next_generation = []
        curGen = curGen + 1
        parentPos = 0;
        while parentPos < len(population):
            children = crossover(population[parents[parentPos]],population[parents[parentPos + 1]])
            if children != None:
                next_generation.append(children[0])
                next_generation.append(children[1])
            parentPos = parentPos + 2
   
        mutatedPopulation = []
        for i in next_generation.copy():
            mutatedPopulation.append(mutation(i))
      
        population = mutatedPopulation
        print("Generation {0} | population  \n".format(curGen) + str(population))
       
        

def bins():
    global VARSET
    global POPULATION_SIZE
    currentBest = [];
    currentBestFitness = 0 
    curGen = 0;
    numItems = 10
    item_number = np.arange(0,numItems)
    VARSET = np.arange(0,numItems)
    POPULATION_SIZE = 10

    lowerBound = 1
    upperBound = 10
    weight = np.random.randint(lowerBound, upperBound, size = numItems)

    binThresh = 20  

    print('The list is as follows:')
    print('Item No.   Weight  ')
    for i in range(item_number.shape[0]):
        print('{0}          {1}        \n'.format(item_number[i], weight[i]))


    population = generate_populationBin(binThresh, weight)
    
    print("population  " + str(population))
   # print('complete code for a combinitorial optimization problem:')
    while (True):  
        curGen = curGen + 1
        fitness = selectionKnap(population, weight, value, knapsack_threshold)
        parents = findParents(fitness, True)

        if curGen > GENERATIONS:
            print ("best fitness  {0} \n".format(currentBestFitness))
            
            print ("best values  {0} \n".format(currentBest))

            for i in range (0,len(currentBest)):
                print ("{}".format(currentBest[i] * (i +1)))
            break;

        if fitness[parents[0]] > currentBestFitness:
            currentBestFitness = fitness[parents[0]]
            currentBest = population[parents[0]]
        next_generation = []
        parentPos = 0;
        while parentPos < len(population):
            children = crossover(population[parents[parentPos]],population[parents[parentPos + 1]])
            if children != None:
                next_generation.append(children[0])
                next_generation.append(children[1])
            parentPos = parentPos + 2
   
        mutatedPopulation = []
        for i in next_generation.copy():
            mutatedPopulation.append(mutation(i))
      
        population = mutatedPopulation
        print("Generation {0} | population  \n".format(curGen) + str(population))


# USE THIS MAIN FUNCTION TO COMPLETE YOUR CODE - MAKE SURE IT WILL RUN FROM COMOND LINE   
def main(): 
    global POPULATION_SIZE 
    global GENERATIONS
    global SOLUTION_FOUND
    global GENE_LENGTH
    #knap()
    #minSum() works hundo % 
    #nQueue()hundo % works
    bins()
 

if __name__ == '__main__': 
    main() 
    
    
    
