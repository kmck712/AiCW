# -*- coding: utf-8 -*-
"""
Complete this code for combinatorial optimization  problem

Please remove author name if generated by machine automatically
Keep you code anonymous

"""

# Use standard python package only.
import random 
import math
import numpy as np
import matplotlib as plt
from numpy import random 

# MINIMUM GLOBAL VARIABLES TO BE USED
POPULATION_SIZE = 50 # Change POPULATION_SIZE to obtain better fitness.

GENERATIONS = 500  # Change GENERATIONS to obtain better fitness.
SOLUTION_FOUND = False

CORSSOVER_RATE = 0.9 # Change CORSSOVER_RATE  to obtain better fitness.
MUTATION_RATE = 0.4 # Change MUTATION_RATE to obtain better fitness.
GENE_LENGTH = 10
VARSET = [0,1]

# MINIMUM FUNCTIONS TO BE USED IN YOU COURSEWORK
def generate_population():
 
    population = []
    population = random.choice(VARSET,size=(POPULATION_SIZE, GENE_LENGTH))
   
    population = population.tolist() 
    
    return population

def generate_populationTrav():
 
    population = []
    for i in range(0,POPULATION_SIZE):
        nextPop = []
        genSet = VARSET.tolist()
        genSet.remove(0)
        nextPop.append(0)
        for j in range(2,GENE_LENGTH):
            nextItem = random.choice(genSet)
            nextPop.append(nextItem)
            genSet.remove(nextItem)
        nextPop.append(0)
        population.append(nextPop)
   
    return population

def compute_fitness(individual):
    
    fitness = sum(individual)
    #print ("current fitness {}\n".format(fitness) )
    return fitness

def compute_fitnessKnap(individual, weights, values, threshold):
    
    fitness = []
    sumW = 0
    sumV = 0
    for i in range(0, len(individual)):
        sumW = sumW + individual[i] * weights[i]
        sumV = sumV + individual[i] * values[i]
    if (sumW > threshold):
        fitness = 0 
    else:
        fitness = sumV
   # print ("sum W {} fitness {} \n".format(sumW , fitness ))
    return fitness

def compute_fitnessQueue(individual):
    fitness = 0
    #index = X value of indexed position = Y
    # deals with the rows
    for i in range(0,len(individual)):
        fitness = fitness + calcDiag(i, individual[i], individual)
        for j in range(0,len(individual)):
           if i != j:
                if individual[j] == individual[i]:
                    fitness = fitness + 1
   # print ("fitness {}\n".format(fitness))
    return fitness

def calcDiag(indPos, indVal, individual):
    
    fitness = 0
    dir = [-1,1]
    for i in dir:
       for j in dir:
        x = indPos + i
        y = indVal + j
        while (x <= 3 and y <= 3 and y >=0  and x >= 0):
            if individual[x] == y:
                fitness = fitness + 1
            x = x + i
            y = y + j

    return fitness

def compute_fitnessTrav(individual, weights):
    
    fitness = 0
    currentW = 0;
    if all(item in individual for item in VARSET) == True:
        for i in range(0, len(individual) -1 ):
            fitness = fitness + weights[currentW][individual[i+1]]
            currentW = individual[i+1]
            #print("fitness for {} to {}  {} current w is now {}\n".format(i , i + 1,weights[i][individual[i+1]],currentW ))
    else:
        fitness = 9999999999;
   # print("travel length {}".format(fitness))
    return fitness

def selectionQueue(population):

    individual = [] 
    for i in population:
        individual.append(compute_fitnessQueue(i))
    return individual

def selectionKnap(population,weights, values, threshold):

    individual = [] 
    for i in population:
        individual.append(compute_fitnessKnap(i, weights, values, threshold))
    
    return individual
    

def selectionTrav(population, weights):

    individual = [] 
    for i in population:
        individual.append(compute_fitnessTrav(i, weights))
    
    return individual

def selection(population):

    individual = [] 
    for i in population:
        individual.append(compute_fitness(i))
    
    return individual

def crossover(first_parent, second_parent, ubCross, lbCross):
   #implimenting single point crossover recombination
    individual = []
    crossProb = random.rand()
    if crossProb < CORSSOVER_RATE:
        pos = random.randint(lbCross, ubCross)
        individual.append(first_parent[:pos] +  second_parent[pos:])
        individual.append(second_parent[:pos] + first_parent[pos:])
        return individual
    else:
        individual.append(first_parent)
        individual.append(second_parent)
        return individual
    return individual



def mutation(individual, ubCross, lbCross):
    
     #need to glabalise the mutation bounds 
    # single bit point mutation
    if random.rand() < MUTATION_RATE:
        posRng = random.randint(lbCross,ubCross)
        newMut = random.choice(VARSET)
        while newMut == individual[posRng]:
            newMut = random.choice(VARSET)
        individual[posRng] = newMut
    
    return individual

#TODO : You can increase number of function to be used to improve your GA code 

def findParents(fitness, order):
    #selection with to find values with lowest zeros 
    #creates a list with the indexs of the genes from greatest fitness to lowest fitness
     parentsIndex = []
     orderedVal = []     
     orderedVal = fitness.copy()
     orderedVal.sort(reverse = order)
   #  print( "best fitness" + str(orderedVal[0]) + "\n")
     for j in range (0, np.size(orderedVal)):
        for i in range(0,np.size(fitness)):
             if  fitness[i] == orderedVal[j]:
                 if i not in parentsIndex:
                    parentsIndex.append(i);
                    break;
     test = fitness.copy()
     test.sort(reverse = True)
     #print('current fittness {} \n'.format(test))
    # print('parent index {} \n '.format(parentsIndex))
     return parentsIndex
    

def knap():
    global GENE_LENGTH 
    GENE_LENGTH = 20
    currentBest = [];
    currentBestFitness = 0 
    curGen = 0;
    winStreak = 0
    winThreshold = 50
    knapsack_threshold = 35 
    item_number = np.arange(1, GENE_LENGTH + 1)
    weight = np.random.randint(1, 15, size =  GENE_LENGTH)
    value = np.random.randint(10, 750, size =  GENE_LENGTH)
    
    print('The item avaliable:')
    print('Item No.   Weight   Value')
    for i in range(item_number.shape[0]):
        print('{0}          {1}         {2}\n'.format(item_number[i], weight[i], value[i]))

    population = generate_population()
    
    while (True):  
        fitness = selectionKnap(population, weight, value, knapsack_threshold)
        parents = findParents(fitness, True)

        if curGen > GENERATIONS or winStreak > winThreshold:
            print ("best fitness  {0} \n".format(currentBestFitness))
            
            print ("best values  {0} \n".format(currentBest))

            for i in range (0,len(currentBest)):
                print ("{}".format(currentBest[i] * (i +1)))
            break;

        if fitness[parents[0]] > currentBestFitness:
            currentBestFitness = fitness[parents[0]]
            currentBest = population[parents[0]]
        else:
            winStreak = winStreak + 1

        curGen = curGen + 1

        next_generation = []
        parentPos = 0;
        while parentPos < len(population):
            children = crossover(population[parents[parentPos]],population[parents[parentPos + 1]], GENE_LENGTH,0)
            if children != None:
                next_generation.append(children[0])
                next_generation.append(children[1])
            parentPos = parentPos + 2
   
        mutatedPopulation = []
        for i in next_generation.copy():
            mutatedPopulation.append(mutation(i,GENE_LENGTH,0))
      
        population = mutatedPopulation


def minSum():
    curGen = 0
    global GENE_LENGTH 
    global VARSET
    GENE_LENGTH = 7
    VARSET = np.arange(0,GENE_LENGTH )

    population = generate_population()
    #print("population {}\n ".format(population))

    while (True):  
        fitness = selection(population)
        parents = findParents(fitness, False)

        if 0 in fitness:
            print ("solution found  {} in generation {} \n Final Population{}\n".format(population[fitness.index(0)],curGen, population))
            break;
        if curGen > GENERATIONS:
            print ("Soloution not found \n")
            print ("last Generation {}\n\n last fitness {}".format(population,fitness))
            break;

        curGen = curGen + 1
        next_generation = []
        parentPos = 0;
        while parentPos < len(population):
            children = crossover(population[parents[parentPos]],population[parents[parentPos + 1]],GENE_LENGTH,0)
            if children != None:
                next_generation.append(children[0])
                next_generation.append(children[1])
            parentPos = parentPos + 2
        mutatedPopulation = []
        for i in next_generation.copy():
            mutatedPopulation.append(mutation(i,GENE_LENGTH,0))
      
        population = mutatedPopulation
       # print("Generation {} | population  \n".format(curGen) + str(population))


def nQueue():
    curGen = 0
    global GENE_LENGTH 
    global VARSET
    GENE_LENGTH = 4
    VARSET = np.arange(0,GENE_LENGTH )
    population = []
    population = generate_population()

   # print("population  {} \n".format(population))
   
    while (True):  
        fitness = selectionQueue(population)
        parents = findParents(fitness, False)

        if 0 in fitness:
            print ("solution found  {} in generation {} \n Final Population{}\n".format(population[fitness.index(0)],curGen, population))
            break;
        if curGen > GENERATIONS:
            print ("Soloution not found \n")
            
            print ("last Generation {}\n last fitness {}".format(population,fitness))
            break;

        next_generation = []
        curGen = curGen + 1
        parentPos = 0;
        while parentPos < len(population):
            children = crossover(population[parents[parentPos]],population[parents[parentPos + 1]], GENE_LENGTH,0)
            if children != None:
                next_generation.append(children[0])
                next_generation.append(children[1])
            parentPos = parentPos + 2
   
        mutatedPopulation = []
        for i in next_generation.copy():
            mutatedPopulation.append(mutation(i,GENE_LENGTH,0))
      
        population = mutatedPopulation
        #print("Generation {0} | population  \n".format(curGen) + str(population))
       
        

def travel():
    global VARSET
    global POPULATION_SIZE
    global GENE_LENGTH 
    currentBest = [];
    currentBestFitness = 99999
    curGen = 0;
    numCities =3
    winStreak = 0
    winThreshold = 50
    

    GENE_LENGTH = numCities + 1
    item_number = np.arange(0, numCities)
    VARSET = np.arange(0, numCities)
    POPULATION_SIZE = 50


    ubCross = GENE_LENGTH - 2
    lbCross = 1

    lowerBound = 1
    upperBound = 10
    weight = np.random.randint(lowerBound, upperBound, size =( numCities,GENE_LENGTH-1))  
    for i in range (0,numCities):
            weight[i][i] = 0
    
    print('The weight of the routes to each city :')
    print('Item No.   Weight  ')
    for i in range(item_number.shape[0]):
        print('{0}          {1}        \n'.format(item_number[i], weight[i]))


    population = generate_populationTrav()
    
    while (True):  
        
        fitness = selectionTrav(population, weight)
        parents = findParents(fitness, False)

        if curGen > GENERATIONS or winStreak > winThreshold:
            print ("best fitness  {0} \n".format(currentBestFitness))
            
            print ("best values  {0} \n".format(currentBest))

            for i in range (0,len(currentBest)):
                print ("{}".format(currentBest[i] * (i +1)))
            break;

        if fitness[parents[0]] < currentBestFitness:
            currentBestFitness = fitness[parents[0]]
            currentBest = population[parents[0]]
        else:
            winStreak = winStreak + 1

        curGen = curGen + 1

        next_generation = []
        parentPos = 0;
        while parentPos < len(population):
            children = crossover(population[parents[parentPos]],population[parents[parentPos + 1]], ubCross, lbCross)
            if children != None:
                next_generation.append(children[0])
                next_generation.append(children[1])
            parentPos = parentPos + 2
   
        mutatedPopulation = []
        for i in next_generation.copy():
            mutatedPopulation.append(mutation(i,ubCross, lbCross))
      
        population = mutatedPopulation
       


# USE THIS MAIN FUNCTION TO COMPLETE YOUR CODE - MAKE SURE IT WILL RUN FROM COMOND LINE   
def main(): 
    end = False
    print ("Welcome to continuous distribution gentic algorithm sim! \n") 
    print("Which problem do you want to solve?\nSum square = 1\nDixon and Price = 2\nLevy = 3\nZakharov = 4\nPerm = 5\n\nPlease input you selection below:\n")
    while end == False:
        inp = input()
        if inp == "1":
            minSum()
        elif inp == "2":
            knap()
        elif inp == "3":
            nQueue()
        elif inp == "4":
            travel()
        elif inp == "0":
            print("Thank you for using this sim\n")
            end =  True
        else:
            print("please type a valid input \n")
  
 

if __name__ == '__main__': 
    main() 
    
    
    
