# -*- coding: utf-8 -*-
"""
Complete this code for continuous optimization  problem

Please remove author name if generated by machine automatically
Keep you code anonymous

"""

# Use standard python package only.
import random 
import math
import numpy as np
import matplotlib as plt
import random as rng
from numpy import random



# MINIMUM GLOBAL VARIABLES TO BE USED
POPULATION_SIZE = 50 # Change POPULATION_SIZE to obtain better fitness.

GENERATIONS = 100 # Change GENERATIONS to obtain better fitness.
SOLUTION_FOUND = False

CORSSOVER_RATE = 0.8 # Change CORSSOVER_RATE  to obtain better fitness.
MUTATION_RATE = 0.2# Change MUTATION_RATE to obtain better fitness.

GENE_LENGTH = 6

# MINIMUM FUNCTIONS TO BE USED IN YOU COURSEWORK
def generate_population(lower_bound, upper_bound):
    ##impliment it with uniform distribution
    
    population = []# Update this line if you need to
    population = np.round(random.uniform(lower_bound, upper_bound, size=(POPULATION_SIZE, GENE_LENGTH)))
    population = population.tolist()
  
    return population


def compute_fitness(individual):
    # fitness function used - sum squares function
    n = GENE_LENGTH
    fitness = 0
    for j in range(0,n):
       fitness = fitness + (j+1)*int(individual[j])^2
    
    return fitness


def selection(population):
    # need to decide on an operation more appropriete
    individual = [] 
    for i in (population):
        individual.append(compute_fitness(i));
    return individual
    

def crossover(first_parent, second_parent):
    #implimenting single point crossover recombination
    individual = []
    survive = np.random.random_sample()#rng.random() 
    print (str(survive) + "\n")
    if survive < CORSSOVER_RATE:
        pos = rng.randint(0,GENE_LENGTH-1)
        individual.append(first_parent[:pos] +  second_parent[pos:])
        individual.append(first_parent[pos:] +  second_parent[:pos])
        return individual
    else:
        return None


def mutation(individual):
    
    # single bit point mutation
    if rng.random() < MUTATION_RATE:
        posRng = rng.randint(0,np.size(individual) -1)
        newMut = rng.randint(-10,10)
        while newMut == individual[posRng]:
            newMut = rng.randint(-10,10)
        individual[posRng] = newMut
    return individual

def findParents(fitness):
     parentIndex = []
     fitness2 = fitness.copy()
     fitness2.sort(reverse = True)
     for j in range (0, np.size(fitness2)):
        for i in range(0,np.size(fitness)):
             if fitness[i] == fitness2[j]:
                 if i not in parentIndex:
                    parentIndex.append(i);
                    break;
     
     return parentIndex


def next_generation(previous_population):
    fitness = selection(previous_population)
    parents = findParents(fitness)

    mutatedPopulation = []
    for i in previous_population.copy():
         mutatedPopulation.append(mutation(i))
    
    next_generation = []
    parentPos = 0;
    while parentPos < len(previous_population):
        children = crossover(previous_population[parents[parentPos]],previous_population[parents[parentPos + 1]])
        if children != None:
            next_generation.append(children[0])
            next_generation.append(children[1])
        parentPos = parentPos + 2
   
    print (" next gen " + str(next_generation) + "\n")
    return next_generation
    



# USE THIS MAIN FUNCTION TO COMPLETE YOUR CODE - MAKE SURE IT WILL RUN FROM COMOND LINE   
def main(): 
    global POPULATION_SIZE 
    global GENERATIONS
    global SOLUTION_FOUND
    global GENE_LENGTH

    currentGeneration = 0
    currentHighestFitness = 0

    #should find a way to change the parts which depends on this
    lower_bound = -10 
    upper_bound = 10
    
    population = generate_population(lower_bound, upper_bound)
    print ("first gen " + str(population) + "\n")
   
    while (SOLUTION_FOUND == False):  # TODO: write your termination condition here or within the loop  
        fitness = selection(population)
        parents = findParents(fitness)
        if fitness[parents[0]] > currentHighestFitness:
                   currentHighestFitness = fitness[parents[0]]
        avg = sum(fitness)/len(fitness)
        print ("Generation {} | population size {} \n".format(currentGeneration, len(population)))
        print ( "Highest Fitness of Generation {} | Highest Fitness overall {} | Generation averge fitness {} \n".format(fitness[parents[0]], currentHighestFitness, avg))
        population  = next_generation(population);

        if currentGeneration < GENERATIONS and len(population) > 1:
            currentGeneration = currentGeneration + 1
        else:
            break;
        
 

if __name__ == '__main__': 
    main() 
    