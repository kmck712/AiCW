# -*- coding: utf-8 -*-
"""
Complete this code for combinatorial optimization  problem

Please remove author name if generated by machine automatically
Keep your code anonymous

"""

# Use standard python package only.
import random 
import math
import numpy as np
import matplotlib as plt


# MINIMUM GLOBAL VARIABLES TO BE USED
POPULATION_SIZE = 5  # Change POPULATION_SIZE to obtain better fitness.
GENE_SIZE = 6
GENERATIONS = 100  # Change GENERATIONS to obtain better fitness.
SOLUTION_FOUND = False
NO_OF_PARENTS = 0


FITNESS_CHOSEN = 1
SELECTION_METHOD = 1
MUTATION_METHOD = 1

CROSSOVER_RATE = 0.8  # Change CROSSOVER_RATE  to obtain better fitness.
MUTATION_RATE = 0.2  # Change MUTATION_RATE to obtain better fitness.

LOWER_BOUND = -10
UPPER_BOUND = 10

# MINIMUM FUNCTIONS TO BE USED IN YOU COURSEWORK


def generate_population(pop_size, gene_size, lower, upper):
    population = []  # Update this line if you need to
    for i in range(pop_size):
        population.append(gen_chromosome(gene_size, lower, upper))
    return population


def gen_chromosome(size, lower, upper):
    chromosome = []
    for i in range(size):
        chromosome.append(gen_gene(lower, upper))
        print(chromosome)
    return chromosome


def gen_gene(lower, upper):
    return random.randrange(lower, upper)


def compute_fitness(individual, FITNESS_CHOICE):
    # TODO : Write your own code to generate fitness function evaluation for your select functions
    print('fitness computed:')

    # fitness = np.nan()
    switcher = {
        1: sum_square
        # 2: weighted_input,
        # 3: levy,
        # 4: trid,
        # 5: griewank,
        # 6: zakharov
    }
    func = switcher.get(FITNESS_CHOICE)
    return func(individual)
    # return fitness


def sum_square(individual):
    # We want the fitness to be larger, the better the implementation.
    # Therefore, the lesser values of 'fitness' are better here.
    n = len(individual)
    fitness = 0
    for j in range(0,n):
     
       fitness = fitness + (j+1)*individual[j]**2
    return fitness


def selection(pop, fitness, Selection_Choice ):
    a = 0
    b = 0

    def roulette_selection(_fitness):
        # calculate sum of fitnesses
        # generate random number between 0 and sumF
        # sum individual fitnesses until sum > RandNum
        target = random.uniform(0, sum(_fitness))
        print("test {}".format(_fitness))
        for n in range(len(_fitness)):
            running_total = sum(_fitness[:n])
            if running_total > target:
                pick = n
                return pop[pick]
            else:
                pass
       #  return pick

    def rank_selection(_fitness):
        # selection with to find values with lowest zeros
        # creates a list with the indexs of the genes from greatest fitness to lowest fitness
        parents_index = []
        ordered_Val = []
        ordered_val = _fitness.copy()
        ordered_val.sort()
        #  print( "best fitness" + str(orderedVal[0]) + "\n")
        for j in range(0, np.size(ordered_val)):
            for i in range(0, np.size(_fitness)):
                if _fitness[i] == ordered_val[j]:
                    if i not in parents_index:
                        parents_index.append(i);
                        break;

        return parents_index

    def random_selection():

        pass

    if Selection_Choice == 1:
        a = roulette_selection(fitness)
        b = roulette_selection(fitness)
    elif Selection_Choice == 2:
        a = rank_selection()
        b = rank_selection()
    else:
        print("ERROR")

    return a, b
    parents = np.empty(())
    individual = []  # Update this line if you need to
    #TODO : Write your own code to for choice  of your selection operator
    
    return individual
    

def crossover(first_parent, second_parent, cross_type):
    def single_point_cross(fp, sp, left, right):
        print("Start of SPC -  f: " + fp + " s: "+sp)
        split = random.randrange(left, right)
        temp = fp[split:]
        fp = fp[:split] + sp[split:]
        sp = sp[:split] + temp
        print("END of SPC -  f: " + fp + " s: "+sp)
        return fp, sp

    def two_point_cross(fp, sp, left, right):
        print("Start of TPC -  f: " + fp + " s: " + sp)
        split = random.randrange(left, right)
        single_point_cross(fp, sp, 0, split)
        print("Middle of TPC -  f: " + fp + " s: " + sp)
        single_point_cross(fp, sp, split, right)
        print("End of TPC -  f: " + fp + " s: "+sp)
        return fp, sp
    # def multipoint_cross(fp, sp, left, right, x):
    if random.random() > CROSSOVER_RATE:

        if cross_type == 1:
            a, b = single_point_cross(first_parent, second_parent, 0, len(first_parent))
            return a, b
        elif cross_type == 2:
            return two_point_cross(first_parent, second_parent, 0, len(first_parent))
        else:
            # return multipoint_cross(first_parent,second_parent, 0, len(first_parent), random.randrange(0,len(first_parent)) )
            pass
    else:
        return first_parent, second_parent
    # TODO: ADD CROSSOVER RATE


def mutation(individual, mutation_choice):

    def bit_flip(to_flip):
        bf = random.randrange(0, len(to_flip))
        to_flip[bf] = -to_flip[bf]
        # if to_flip[bf] == 0:
        #     to_flip[bf] = 1
        # else:
        #     to_flip[bf] = 0
        return to_flip

    def swap(to_swap):
        swap1 = random.randrange(0, len(to_swap))
        swap2 = random.randrange(0, len(to_swap))
        temp = to_swap[swap1]
        to_swap[swap1] = to_swap[swap2]
        to_swap[swap1] = temp
        return to_swap

    def inversion(to_inv):
        inv1 = random.randrange(0, len(to_inv))
        inv2 = random.randrange(0, len(to_inv))
        if inv1 < inv2:
            to_inv = to_inv[:inv1] + to_inv[inv1:inv2].reverse() + to_inv[inv2:]
        elif inv2 < inv1:
            to_inv = to_inv[:inv2] + to_inv[inv2:inv1].reverse() + to_inv[inv1:]
        else:
            to_inv = to_inv
        return to_inv
    # def scramble():

    # def random():
    if random.random() > MUTATION_RATE:
        if mutation_choice == 1:
            mutated = bit_flip(individual)
        elif mutation_choice == 2:
            mutated = swap(individual)
        elif mutation_choice == 3:
            mutated = inversion(individual)
        else:
            print("Bad Input -> Mutation Choice")
    else:
        mutated = individual
        pass
    return mutated

# TODO : You can increase number of function to be used to improve your GA code


def end_check(pop):
    if FITNESS_CHOSEN == 1:
        ideal_individual = [0 for x in range(GENE_SIZE)]
    for x in pop:
        if len([i for i, j in zip(x, ideal_individual) if i == j]) == GENE_SIZE:
            print("\nIdeal Individual Found!\n")
            return True
    return False


def findBestInput(population, fitness):
    best_fitness = max(fitness)
    individual_index = fitness.index(best_fitness)
    return population[individual_index]


def complete_GA(pop_size, gene_size, lb, ub, mode):
    global SOLUTION_FOUND
    hardcoded_settings()
    set_bounds(1)
    mydict = {}
    gen_count = 1
    pop = generate_population(pop_size, gene_size, lb, ub)
    print ("population {}".format(pop))
    f = []
    for x in pop:
        f.append(compute_fitness(x, mode))
    print(f)
    print(len(f))
    mydict[gen_count] = max(f)

    if end_check(pop):
        SOLUTION_FOUND = True
        print("Found after ", gen_count, " generation(s)")
    else:
        gen_count += 1

        while not SOLUTION_FOUND and gen_count <= GENERATIONS:

            parent_a, parent_b = selection(pop, f, SELECTION_METHOD)
            print("pa {} pb {}".format(len(parent_a), len(parent_b)))
            if SELECTION_METHOD == 1:
                offspring_a, offspring_b = crossover(parent_a, parent_b, SELECTION_METHOD)
                offspring_a = mutation(offspring_a, MUTATION_METHOD)
                offspring_b = mutation(offspring_b, MUTATION_METHOD)
                pop.append(offspring_a)
                pop.append(offspring_b)
            else:
                print("hola")
                offspring_a, offspring_b = crossover(parent_a, parent_b, SELECTION_METHOD)
                offspring_a = mutation(offspring_a, MUTATION_METHOD)
                offspring_b = mutation(offspring_b, MUTATION_METHOD)
            for x in pop:
                fitness = compute_fitness(x, FITNESS_CHOSEN)
            mydict[gen_count] = max(f)
            if end_check(pop):
                SOLUTION_FOUND = True
                print("Found after ", gen_count, " generation(s)")
            else:
                gen_count += 1
    print("Best Individual: ", findBestInput(pop, f))
    print("Best final outcome: ", max(f))
    #
    #
    #
    #
    # while (gen_count <= GENERATIONS and SOLUTION_FOUND != True):
    #     ## Parent Selection Stage
    #     parents = selection(population, fitness)
    #     if SELECTION_METHOD == 1:
    #         # Roulette Wheel Selection --> NewPop = Parents + Offspring
    #         offspring = crossover(parents, POPULATION_SIZE - PARENT_NO)
    #         ## Mutation
    #         offspring = mutation(offspring)
    #         ## Survive
    #         population = list(parents) + list(offspring)
    #     else:
    #         # Steady State Selection --> NewPop = oldPop - weakest members + offspring
    #         offspring = crossover(parents, PARENT_NO)
    #         ## Mutation
    #         offspring = mutation(offspring)
    #         ## Survive
    #         population = list(population) + list(offspring)
    #
    #     fitness = [compute_fitness(x) for x in population]
    #     results_dict[gen_count] = max(fitness)
    # return mydict
    #

def next_generation(previous_population):
    #TODO : Write your own code to generate next 
    fitness = compute_fitness(previous_population, FITNESS_CHOSEN)
    parent_a, parent_b = selection(fitness)
    next_generation = []

    
    print(' ') # Print appropriate generation information here. 
    return next_generation


def initialise_settings():
    global CROSSOVER_RATE
    global GENE_SIZE
    global POPULATION_SIZE
    global MUTATION_RATE
    global GENERATIONS
    complete = False
    while not complete:
        print("what Crossover Rate do you want? \n")
        inp = input()
        CROSSOVER_RATE = float(inp)

        print("what Mutation Rate do you want? \n")
        inp = input()
        MUTATION_RATE = float(inp)

        print("what Gene Length do you want? \n")
        inp = input()
        GENE_SIZE = float(inp)

        print("What Population Size do you want? \n")
        inp = input()
        POPULATION_SIZE = float(inp)

        print("How many Generation do you want? \n")
        inp = input()
        GENERATIONS = float(inp)
        complete = True


def hardcoded_settings():
    global CROSSOVER_RATE
    global MUTATION_RATE
    global GENE_SIZE
    global POPULATION_SIZE
    global GENERATIONS
    CROSSOVER_RATE = 1
    MUTATION_RATE = 0.05
    GENE_SIZE = 2
    POPULATION_SIZE = 50
    GENERATIONS = 10000


def set_bounds(func):
    global LOWER_BOUND
    global UPPER_BOUND
    if func == 1:
        LOWER_BOUND = -10
        UPPER_BOUND = 10
    else:
        pass


# USE THIS MAIN FUNCTION TO COMPLETE YOUR CODE - MAKE SURE IT WILL RUN FROM COMMAND LINE
def main():
    global SOLUTION_FOUND
    SOLUTION_FOUND = False

    results_dict = [dict()]
    results_dict[0] = complete_GA(POPULATION_SIZE, GENE_SIZE, LOWER_BOUND, UPPER_BOUND, 1)
    # complete_GA(POPULATION_SIZE, GENE_SIZE, LOWERBOUND, UPPERBOUND)

    print('complete code for a Continuous optimization problem:')
    while (True):  # TODO: write your termination condition here or within the loop 
        #TODO: write your generation propagation code here 


        #TODO: present innovative graphical illustration like plots and presentation of genetic algorithm results 
        #This is free (as you like) innovative part of the assessment.
        break # Remove this line
 

if __name__ == '__main__': 
    main() 
    
    
    
